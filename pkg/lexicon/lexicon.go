package lexicon

import (
	"fmt"
	"strings"
	"sync"
)

var (
	lexicon = map[string]string{
		"greeting": ` ____  _     ____  ____  _  __   _____  _     ____  _____  _     _____
/  _ \/ \   /  _ \/   _\/ |/ /  /__ __\/ \ /\/  __\/__ __\/ \   /  __/
| | //| |   | / \||  /  |   /     / \  | | |||  \/|  / \  | |   |  \  
| |_\\| |_/\| |-|||  \_ |   \     | |  | \_/||    /  | |  | |_/\|  /_ 
\____/\____/\_/ \|\____/\_|\_\    \_/  \____/\_/\_\  \_/  \____/\____\`,
	}

	errorLexicon = map[string]string{
		"":                    "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫...",
		"general":             "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫...",
		"parserError":         "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞–ø–∏—Å–∞–Ω–∞ –∫–æ–º–∞–Ω–¥–∞.",
		"studyEntityNotFound": "–ù–µ—Ç —Ç–∞–∫–æ–π –≥—Ä—É–ø–ø—ã/–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è.",
		"unknownCommand":      "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.",
	}
	mutex = &sync.RWMutex{}
)

func Get(key string) string {
	mutex.RLock()
	defer mutex.RUnlock()

	val, exists := lexicon[key]
	if !exists {
		return "null"
	}
	return val
}

// Get display error message by key and provide metadata
func Error(key string, metadata ...any) string {
	mutex.RLock()
	defer mutex.RUnlock()

	val, exists := errorLexicon[key]
	if !exists {
		val = errorLexicon[""]
	}
	data := make([]string, 0)
	for _, item := range metadata {
		switch v := item.(type) {
		case string:
			data = append(data, v)
		case fmt.Stringer:
			data = append(data, v.String())
		case error:
			data = append(data, v.Error())
		default:
			data = append(data, fmt.Sprintf("%v", v))
		}
	}
	if len(data) != 0 {
		return "üö´ –û—à–∏–±–∫–∞!\n\n" + val + " " + strings.Join(data, ", ") + "\n\n–ü—Ä–æ–ø–∏—à–∏—Ç–µ <b>–ø–æ–º–æ—â—å</b> –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å–ø—Ä–∞–≤–∫–∏ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É"
	} else {
		return "üö´ –û—à–∏–±–∫–∞!\n\n" + val + "\n\n–ü—Ä–æ–ø–∏—à–∏—Ç–µ <b>–ø–æ–º–æ—â—å</b> –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å–ø—Ä–∞–≤–∫–∏ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É"
	}
}
